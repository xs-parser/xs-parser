plugins {
	id 'checkstyle'
	id 'jacoco'
	id 'java-library'
	id 'maven-publish'
	id 'signing'
	id 'org.sonarqube' version '7.0.1.6134' apply false
}

if (System.getenv('SONAR_TOKEN') != null) {
	apply plugin: 'org.sonarqube'
}

repositories {
	mavenCentral()
}

dependencies {
	compileOnly 'net.sf.saxon:Saxon-HE:12.+'
	testImplementation 'junit:junit:4.+'
	testRuntimeOnly 'net.sf.saxon:Saxon-HE:12.+'
}

java {
	withSourcesJar()
	withJavadocJar()
}

compileJava {
	sourceCompatibility = JavaVersion.VERSION_1_8
	targetCompatibility = JavaVersion.VERSION_1_8
}

compileTestJava {
	sourceCompatibility = JavaVersion.VERSION_11
	targetCompatibility = JavaVersion.VERSION_11
}

tasks.withType(JavaCompile) {
	options.encoding = 'UTF-8'
}

abstract class GitDescribeTagsValueSource implements ValueSource<String, org.gradle.api.provider.ValueSourceParameters.None> {
	@Inject
	abstract ExecOperations getExecOperations()

	String obtain() {
		ByteArrayOutputStream stdout = new ByteArrayOutputStream()
		try {
			def result = execOperations.exec {
				it.commandLine 'git', 'describe', '--tags', '--match', 'v[0-9]*'
				it.standardOutput = stdout
			}
			if (result.getExitValue() == 0) {
				return stdout.toString().trim().substring(1)
			}
		} catch (e) {
			println e
		}
		return 'unspecified'
	}
}

// Run with -Psnapshot to enable SNAPSHOT builds
def isSnapshot = project.hasProperty('snapshot')
def gitDescribeTagsProvider = providers.of(GitDescribeTagsValueSource.class) {}
version = gitDescribeTagsProvider.get() + (isSnapshot ? '-SNAPSHOT' : '')

test {
	finalizedBy jacocoTestReport
	maxHeapSize = '2048m'
	maxParallelForks = Runtime.runtime.availableProcessors().intdiv(2) ?: 1
	systemProperty 'XS_PARSER_VERBOSE', true
	testLogging {
		exceptionFormat = 'full'
	}
}

javadoc {
	exclude 'xs/parser/internal/**'
	options.addBooleanOption('Werror', true)
	options.encoding = 'UTF-8'
	options.memberLevel = JavadocMemberLevel.PUBLIC
}

jar {
	manifest {
		attributes 'Implementation-Title': project.name,
				'Implementation-Version': project.version,
				'Specification-Title': 'XML Schema Definition Language (XSD)',
				'Specification-Vendor': 'W3C',
				'Specification-Version': '1.1',
				'Sealed': true
	}
}

tasks.withType(Jar) {
	from('LICENSE.md') {
		into 'META-INF'
	}
	from('DISCLAIMER.md') {
		into 'META-INF'
	}
}

jacocoTestReport {
	dependsOn test
	reports {
		xml.required = true
		html.required = true
	}
}

def getDescription = { ->
	def desc = file('README.md').text.substring('# Description'.length()).trim().replace('\r\n', '\n').replace('\r', '\n')
	return desc.substring(0, desc.indexOf('![')).trim().replaceAll('\n+', ' ').replace('`', '')
}

publishing {
	repositories {
		maven {
			url = { isSnapshot ? System.getenv('SONATYPE_SNAPSHOT_REPO_URL') : System.getenv('SONATYPE_RELEASE_REPO_URL') }
			credentials {
				username = System.getenv('SONATYPE_USERNAME')
				password = System.getenv('SONATYPE_PASSWORD')
			}
		}
	}
	publications {
		sonatype(MavenPublication) {
			artifactId = artifact
			from components.java
			pom {
				def repoUrl = System.getenv('GITHUB_SERVER_URL') + '/' + System.getenv('GITHUB_REPOSITORY')
				def baseRepoUrl = repoUrl.substring('https://'.length())
				name = rootProject.name
				description = getDescription()
				url = repoUrl
				organization {
					name = group
					url = repoUrl.substring(0, repoUrl.lastIndexOf('/'))
				}
				issueManagement {
					system = 'GitHub'
					url = "${repoUrl}/issues"
				}
				licenses {
					license {
						name = file('LICENSE.md').text.split('\n', 2)[0].trim()
						url = "${repoUrl}/blob/main/LICENSE.md"
					}
				}
				scm {
					connection = "scm:git:git://${baseRepoUrl}.git"
					developerConnection = "scm:git:ssh://${baseRepoUrl}.git"
					url = repoUrl
				}
				withXml {
					def devs = asNode().appendNode('developers')
					def authors = (file('CONTRIBUTORS.md').text =~ /- Copyright [0-9]{4}(-([0-9]{4}|present))? (.*?) <(.*?)>/).findAll()
					authors.each {
						def dev = devs.appendNode('developer')
						dev.appendNode('name', it[3])
						dev.appendNode('email', it[4])
					}
				}
			}
		}
	}
}

signing {
	required = { gradle.taskGraph.hasTask('uploadArchives') }
	def signingKey = System.getenv('PGP_SIGNING_KEY')
	def signingPassword = System.getenv('PGP_SIGNING_PASSWORD')
	useInMemoryPgpKeys(signingKey, signingPassword)
	sign publishing.publications
}
